<!DOCTYPE html>
<html lang="en">

  <head>

    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>An Empirical Catalog of Code Smells for the Presentation Layer of Android Apps.</title>

    <!-- Bootstrap core CSS -->
    <link href="vendor/bootstrap/css/bootstrap.min.css" rel="stylesheet">

    <!-- Custom fonts for this template -->
    <link href="https://fonts.googleapis.com/css?family=Saira+Extra+Condensed:500,700" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css?family=Muli:400,400i,800,800i" rel="stylesheet">
    <link href="vendor/fontawesome-free/css/all.min.css" rel="stylesheet">

    <!-- Custom styles for this template -->
    <link href="css/resume.min.css" rel="stylesheet">

    <script src="https://cdn.rawgit.com/google/code-prettify/master/loader/run_prettify.js"></script>

  </head>

  <body id="page-top">

    <nav class="navbar navbar-expand-lg navbar-dark bg-primary fixed-top" id="sideNav">
      <a class="navbar-brand js-scroll-trigger" href="#page-top">
        <span class="d-block d-lg-none">Durelli</span>
        <span class="d-none d-lg-block">
          <img class="img-fluid img-profile mx-auto" src="img/android.png" alt="">
        </span>
      </a>
      <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
        <span class="navbar-toggler-icon"></span>
      </button>
      <div class="collapse navbar-collapse" id="navbarSupportedContent">
        <ul class="navbar-nav">
          <li class="nav-item">
            <a class="nav-link js-scroll-trigger" href="#about">Paper info.</a>
          </li>
          <li class="nav-item">
            <a class="nav-link js-scroll-trigger" href="#codesmells">Component Smells</a>
          </li>
          <li class="nav-item">
            <a class="nav-link js-scroll-trigger" href="#resourcesmells">Resource Smells</a>
          </li>
        </ul>
      </div>
    </nav>

    <div class="container-fluid p-0">

      <section class="resume-section p-3 p-lg-5 d-flex d-column" id="about">
        <div class="my-auto">
          <h1 class="mb-0">Title: An Empirical Catalog of Code Smells for the Presentation Layer of Android Apps.
          </h1>
          <div class="subheading mb-5">Authors: Suelen Goularte Carvalho, Maurício Aniche, Júlio Veríssimo, Rafael S. Durelli, and Marco Aurélio Gerosa ·<p>
          </div>
          <p class="lead mb-5" align="justify"><b>Abstract:</b> Developers frequently seek code to be refactored, searching, for example, for code smells.
            Although the literature presents a variety of code smells, such as <i><b>God Class</b></i>
            and <i><b>Long Method</i></b>, different technologies are not taken into account.
            When it comes to the presentation layer, Android apps are a special kind of software:
            they need to implement specific architectural decisions from the Android platform itself (such as modeling <i><b>Activities</i></b>,
            <i><b>Fragments</i></b>, and <i><b>Listeners</i></b> to events)
            as well as deal with and integrate different types of resources (such as layouts and images).
            We investigate what code smells developers perceive in the presentation layer of Android apps.
            Through a three-step study that involved 300 Android developers, we devised <b>20 specific code smells</b> and collected the developers’ perceptions of their frequency and importance.
            We implemented a <a href="https://github.com/julioverissimo88/AndroidUIDetector">tool</a> that automates the identification of <b>80% (16/20)</b> of
            these smells. To validate we carried out an empirical study over the prevalence of these smells.
            The study was performed involving <b>619</b> open-source apps from F-Droid.
            Our findings suggest that: 1) there exist code smells specific to the presentation layer of Android apps; 2) developers consider these code smells to be of high importance and frequent occurrence;
            and 3) developers perceive classes affected by the smells as problematic when compared to clean classes.
            These results may help practitioners and tool developers while searching for potentially problematic pieces of code in Android Apps.</p>
        </div>
      </section>

      <hr class="m-0">

      <section class="resume-section p-3 p-lg-5 d-flex flex-column" id="codesmells">
        <div class="my-auto">
          <h2 class="mb-5">Component Smells.</h2>

          <div class="subheading mb-5">Nine Component Smells are presented here.<p></div>

          <div class="resume-item d-flex flex-column flex-md-row mb-5">
            <div class="resume-content mr-auto">
              <h3 class="mb-0">Brain UI Component</h3>
              <p align="justify"><i><b>Activities</i></b>, <i><b>Fragments</i></b>, and <i><b>Adapters</i></b> should be responsible for presenting, interacting, and updating the UI only.
                In other words, they should be responsible for any view logic that the app might have.
                Executing any business logic, on the other hand, should happen somewhere else.
                The UI layer should not contain details that are related to the domain.
                The existence of code related to business logic, I/O operations, conversion of data, or static fields in these elements are signs of code smell.</p>

                <div class="subheading mb-3">Example:</div>
                <pre class="prettyprint lang-java">
public class MainActivity extends AppCompatActivity {
    // other codes here

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);

        CardRepositoty repository = new CardRepositoty();
        repository.checkCardLimit()
                .observeOn(AndroidSchedulers.mainThread())
                .subscribe(new Subscriber&lt;LimitResponse>() {
                    @Override
                    public void onCompleted() {
                        dismissProgress();
                    }

                    @Override
                    public void onError(Throwable throwable) {
                        dismissProgress();
                        ErrorManager errorManager = new ErrorManager(throwable);
                        Exception exception = errorManager.parseError();
                        if (exception instanceof ForbiddenException) {
                            showForbidden();
                        } else {
                            showError(exception.getMessage());
                        }
                    }

                    @Override
                    public void onNext(LimitResponse limitResponse) {
                        limit = limitResponse.getDisponibGlobalCredito();

                        if (limit < 0) {
                            binding.limit.setText("R$ 0,00");
                        } else {
                            binding.limit.setText(new DecimalUtil().convertToReal(limit));
                        }
                    }
                });
    }

    // other codes here
}</pre>
                <div class="subheading mb-3">Refactoring suggestion:</div>
                <p align="justify">Only code related to the UI in <i><b>Activities</b></i>, <i><b>Fragments</b></i>, <i><b>Adapters</b></i>,
                  and <i><b>Listeners</b></i>.
                  Break all business logic into two or more classes.</p>
            </div>
          </div>

          <div class="resume-item d-flex flex-column flex-md-row mb-5">
            <div class="resume-content mr-auto">
              <h3 class="mb-0">Coupled UI Component</h3>
              <p align="justify"><i><b>Fragments</b></i>, <i><b>Adapters</i></b>, and <i><b>Listeners</i></b>,
                in order to be reused, should not have direct reference to who uses them.
                The existence of direct reference to <i><b>Activities</i></b> or <i><b>Fragments</i></b> in these elements is an evidence of code smell.</p>
              <div class="subheading mb-3">Example:</div>
              <pre class="prettyprint lang-java">
public class CloudSheetFragment extends BottomSheetDialogFragment {
    // other codes here

    @Override
    public void setupDialog(Dialog dialog, int style) {
        super.setupDialog(dialog, style);

        rootView = getActivity().getLayoutInflater().inflate(R.layout.fragment_sheet_cloud, null);

        if (((MainActivity) getActivity()).getAppTheme().equals(AppTheme.DARK)) {
            rootView.setBackgroundColor(Utils.getColor(getContext(), R.color.holo_dark_background));
        } else {
            rootView.setBackgroundColor(Utils.getColor(getContext(), android.R.color.white));
        }

        dialog.setContentView(rootView);
    }
    // other codes here
}</pre>
                <div class="subheading mb-3">Refactoring suggestion:</div>
                <p align="justify">Make the <i><b>UI</i></b> components reusable. Therefore,
                  one should avoid dependence on other components of the application.
                  Break the <i><b>UI</i></b> components so they are reusable.</p>
            </div>
          </div>

          <div class="resume-item d-flex flex-column flex-md-row mb-5">
            <div class="resume-content mr-auto">
              <h3 class="mb-0">Suspicious Behavior</h3>
              <p align="justify"><i><b>Activities</i></b>, <i><b>Fragments</i></b>, and <i><b>Adapters</i></b> should not contain, in its source code, the implementation of their event handlers.
                First, event handling code, when embedded into one of aforementioned components, is implemented through anonymous or internal classes.
                As the interfaces that these event handlers need to implement are often complex, the source code of the <i><b>Activities</i></b>, <i><b>Fragments</i></b>, and <i><b>Adapters</i></b> becomes less readable.
                Second, an event handler often makes use of the business rules and the domain model of the app.
                A less attentive developer may then write these business rules directly into the event handler (which then leads us to a possible Brain UI Component smell).
                The use of anonymous classes or internal classes to implement Listeners to respond to user events is a sign of code smell.</p>
            <div class="subheading mb-3">Example:</div>
            <pre class="prettyprint lang-java">
public class SettingsActivity extends AppCompatActivity {
    // other codes here

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_settings);

        binding.currencySwitch.setOnCheckedChangeListener(new CompoundButton.OnCheckedChangeListener() {
            @Override
            public void onCheckedChanged(CompoundButton compoundButton, boolean bChecked) {
                if (bChecked) {
                    binding.currencySwitch.setChecked(true);
                    editor.putString("currency", "USD");
                    editor.commit();
                } else {
                    binding.currencySwitch.setChecked(false);
                    editor.putString("currency", "EUR");
                    editor.commit();
                }
            }
        });

        binding.periodInput.setText(this.period);
        binding.periodInput.addTextChangedListener(new TextWatcher() {
            @Override
            public void onTextChanged(CharSequence s, int start, int before, int count) { }

            @Override
            public void beforeTextChanged(CharSequence s, int start, int count, int after) { }

            @Override
            public void afterTextChanged(Editable s) {
                period = binding.periodInput.getText().toString();
                if (period.equals("")) {
                    editor.putString("period", "30");
                    editor.commit();
                } else {
                    editor.putString("period", period);
                    editor.commit();
                }
            }
        });

        TextView aboutText = (TextView) findViewById(R.id.about);
        aboutText.setMovementMethod(LinkMovementMethod.getInstance());
    }
    // other codes here
}</pre>

                <div class="subheading mb-3">Refactoring suggestion:</div>
                <p align="justify">Prefer to state the listeners with implements and overwrite methods than to make one set in the listener object itself.</p>
            </div>
          </div>

          <div class="resume-item d-flex flex-column flex-md-row mb-5">
            <div class="resume-content mr-auto">
              <h3 class="mb-0">Fool Adapter</h3>
              <p align="justify">This smell is present when <i><b>Adapters</i></b> do not reuse instances of the views that represent the fields that will be populated for each item of a collection by means of the <i><b>View Holder</i></b> pattern.</p>
            <div class="subheading mb-3">Example:</div>
            <pre class="prettyprint lang-java">
public class ProfileAdapter extends ArrayAdapter&lt;User> {
    // other codes here

    public DrawerAdapter(Context context, ArrayList&lt;User> users) {
        // ...
    }

    @Override
    public View getView(final int position, View convertView, ViewGroup parent) {
        View view = inflater.inflate(R.layout.profile_item, parent, false);
        TextView txtName = (TextView) view.findViewById(R.id.name);
        TextView txtSurname = (TextView) view.findViewById(R.id.surname);
        TextView txtEmail = (TextView) view.findViewById(R.id.email);
        ImageView imageView = (ImageView) view.findViewById(R.id.icon);

        User user = (User) getItem(position);
        txtName.setText(item.getName());
        txtSurname.setText(item.getSurname());
        txtEmail.setText(item.getEmail());
        imageView.setImageDrawable(item.getIcon());
        imageView.clearColorFilter();

        // ...

        return view;
    }
    // other codes here
}</pre>
                <div class="subheading mb-3">Refactoring suggestion:</div>
                <p align="justify">It is a good practice to use the <i><b>View Holder Pattern</i></b>.</p>
            </div>
          </div>

          <div class="resume-item d-flex flex-column flex-md-row mb-5">
            <div class="resume-content mr-auto">
              <h3 class="mb-0">Absence of an Architecture</h3>
              <p align="justify">This smell emerges when one cannot easily identify how the components are organized.
                Developers cannot identify whether the application makes use of <i><b>Model View Controller (MVC)</i></b>, <i><b>Model View Presenter (MVP)</i></b>, or <i><b>Model View ViewModel (MVVM)</i></b>.</p>
            <div class="subheading mb-3">Example:</div>
            <pre class="prettyprint lang-java">
public class MainMenuActivity extends BaseActivity {
    // other codes here

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        binding = DataBindingUtil.setContentView(this, R.layout.activity_main_menu);

        if (getIntent().getExtras() != null) {
            visitorId = getIntent().getExtras().getInt(Constants.RegisterVisitor.ARGUMENT_VISITOR_ID);
        }

        setupToolbar();
        setListeners();
        if (!hasGpsPermissionGranted) {
            doLogin();
        }
        // ...
    }

    @Override
    protected void onResume() {
        super.onResume();
        name = PreferencesUtil.getString(this, Constants.NAME, "");
        isVisitor = PreferencesUtil.isVisitor(binding.getRoot().getContext());

        user = PreferencesUtil.getUser(this);
        if (user != null && !isVisitor) {
            doLimit();
        }

        if (!TextUtils.isEmpty(name) && !isVisitor) {
            String[] nameSplit = name.split(Constants.WHITESPACE);
            name = nameSplit[0] + Constants.WHITESPACE + nameSplit[1];
            binding.includeAccountDetails.textviewUserName.setText(name);
        } else {
            binding.includeAccountDetails.textviewUserName.setText(R.string.visitor_default_name);
        }

        // ...
    }

    private void doLogin() {
        final Intent intent = getIntent();
        if (intent.hasExtra(Constants.SharedPreferences.CPF) && intent.hasExtra(Constants.SharedPreferences.PASSWORD)) {
            userCpf = intent.getStringExtra(Constants.SharedPreferences.CPF);
            userPassword = intent.getStringExtra(Constants.SharedPreferences.PASSWORD);
            loginData = createLoginData(userCpf, userPassword);

            showProgress(context.getString(R.string.dialog_message_do_login));
            repository.doLogin(loginData)
                .observeOn(AndroidSchedulers.mainThread())
                .subscribe(new Subscriber&lt;LoginResponse>() {
                    @Override
                    public void onCompleted() {}

                    @Override
                    public void onError(Throwable throwable) {
                        dismissProgress();
                        ErrorManager errorManager = new ErrorManager(throwable);
                        Exception exception = errorManager.parseError();
                        if (exception instanceof ForbiddenException) {
                            showForbidden();
                        } else {
                            showError(exception.getMessage());
                        }
                    }

                    @Override
                    public void onNext(LoginResponse loginResponse) {
                        User user = loginResponse.getUser();
                        if (user != null) {
                            saveUser(loginResponse.getUser(), loginData.getPassword());
                        }
                    }
                });
        } else {
            loadSettings();
        }
    }

    public void checkLimitResponseSuccess(LimitResponse limitResponse) {
        limit = limit < 0 ? 0 : limitResponse.getValue();
        binding.includeAccountDetails.textviewBalanceValue.setText(CurrencyUtil.convertToCurrency(String.valueOf(getlimit())));
    }

    // other codes here
}</pre>
                <div class="subheading mb-3">Refactoring suggestion:</div>
                <p align="justify">Try to break all artifacts in order to follow at least one architecture such as: <i><b>Model View Controller (MVC)</i></b>, <i><b>Model View Presenter (MVP)</i></b>, or <i><b>Model View ViewModel (MVVM)</i></b></p>
            </div>
          </div>

          <div class="resume-item d-flex flex-column flex-md-row mb-5">
            <div class="resume-content mr-auto">
              <h3 class="mb-0">Excessive Use of Fragments</h3>
              <p align="justify">This smell emerges when <i><b>Fragments</i></b> are used without an explicit need.
                Examples are applications that do not (need not to) support tablets, or when <i><b>Fragments</i></b> are used in only a single screen of the app.</p>

              <div class="subheading mb-3">Refactoring suggestion:</div>
              <p align="justify">It is not a good practice to use a lot of <i><b>Fragments</i></b>. Transform some <i><b>Fragments</i></b> into <i><b>Activities</i></b> and try to use <i><b>Fragments</i></b> just with <i><b>View Pagers</i></b>.</p>
            </div>
          </div>

          <div class="resume-item d-flex flex-column flex-md-row mb-5">
            <div class="resume-content mr-auto">
              <h3 class="mb-0">UI Component Doing I/O</h3>
              <p align="justify"><i><b>Activities</i></b>, <i><b>Fragments</i></b>, and <i><b>Adapters</i></b> performing I/O operations, such as database and file access, cause this smell.</p>
            <div class="subheading mb-3">Example:</div>
            <pre class="prettyprint lang-java">
public class MainActivity extends AppCompatActivity {
    // other codes here

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);

        TextView aboutText = (TextView) findViewById(R.id.about);
        aboutText.setMovementMethod(LinkMovementMethod.getInstance());

        User user = userRepository.getUser();

        SharedPreferences sharedPreferences = activity.getSharedPreferences(SHARED_TUTO, Context.MODE_PRIVATE);
        sharedPreferences.edit().putString(USER_NAME, user.getName()).apply();

        // ...
    }

    // other codes here
}</pre>
                <div class="subheading mb-3">Refactoring suggestion:</div>
                <p align="justify">Remove all I/O direct access from <i><b>Activities</i></b>, <i><b>Fragments</i></b>, and <i><b>Adapters</i></b>.</p>
            </div>
          </div>

          <div class="resume-item d-flex flex-column flex-md-row mb-5">
            <div class="resume-content mr-auto">
              <h3 class="mb-0">No Use of Fragments</h3>
              <p align="justify"><i><b>Fragments</i></b> can decouple UI with behavior pieces.
                The non use of <i><b>Fragments</i></b> can be a smell in apps that are visually rich.
                Such apps contain a high number of different behaviors, animations, and events to handle.
                If all the implementation complexity relies on a single <i><b>Activity</i></b>, for example,
                this class will be highly complex and hard to understand.
                Moreover, visually rich apps are also often responsive, i.e., have different UIs for different screen sizes.
                In this case, not using <i><b>Fragments</i></b> will hinder code reuse.
                This code smell emerges when view components, e.g., <i><b>EditTexts</i></b> or <i><b>Spinners</i></b>, are directly used by an <i><b>Activity</i></b> instead of <i><b>Fragment</i></b>.</p>
                <div class="subheading mb-3">Refactoring suggestion:</div>
                <p align="justify">Remove direct access to view components in <i><b>Activity</i></b>.
                  Create <i><b>Fragments</i></b> to decouple and improve the reuse all view components.</p>
            </div>
          </div>

          <div class="resume-item d-flex flex-column flex-md-row mb-5">
            <div class="resume-content mr-auto">
              <h3 class="mb-0">Flex Adapter</h3>
              <p align="justify"><i><b>Adapters</i></b> should be responsible for populating a view from a single object.
                The code smell emerges when <i><b>Adapters</i></b> contain business logic and make business decisions.
                As we discussed in the <i><b>Brain UI Component smell</i></b>, UI logic and business rules should be apart from each other.</p>
            <div class="subheading mb-3">Example:</div>
            <pre class="prettyprint lang-java">
public class CityWeatherAdapter extends RecyclerView.Adapter&lt;CityWeatherAdapter.ViewHolder> {
    // other codes here

    @Override
    public ViewHolder onCreateViewHolder(ViewGroup viewGroup, int viewType) {
        View view;
        if (viewType == OVERVIEW) {
            view = LayoutInflater.from(viewGroup.getContext()).inflate(R.layout.card_overview, viewGroup, false);
            return new OverViewHolder(v);

        } else if (viewType == DETAILS) {
            view = LayoutInflater.from(viewGroup.getContext()).inflate(R.layout.card_details, viewGroup, false);
            return new DetailViewHolder(v);

        } else if (viewType == WEEK) {
            view = LayoutInflater.from(viewGroup.getContext()).inflate(R.layout.card_week, viewGroup, false);
            return new WeekViewHolder(v);
        }
        // ...
    }

    @Override
    public void onBindViewHolder(ViewHolder viewHolder, final int position) {

        if (viewHolder.getItemViewType() == OVERVIEW) {
            OverViewHolder holder = (OverViewHolder) viewHolder;
            // ...

        } else if (viewHolder.getItemViewType() == DETAILS) {
            DetailViewHolder holder = (DetailViewHolder) viewHolder;
            // ...

        } else if (viewHolder.getItemViewType() == WEEK) {
            WeekViewHolder holder = (WeekViewHolder) viewHolder;
            // ...

        }
        // ...
    }

    public static class ViewHolder extends RecyclerView.ViewHolder {
        public ViewHolder(View v) {
            super(v);
        }
    }

    public class OverViewHolder extends ViewHolder {
        TextView temperature;
        ImageView weather;

        public OverViewHolder(View v) {
            super(v);
            this.temperature = (TextView) v.findViewById(R.id.activity_city_weather_temperature);
            this.weather = (ImageView) v.findViewById(R.id.activity_city_weather_image_view);
        }
    }

    // others ViewHolders and codes here
}</pre>

                <div class="subheading mb-3">Refactoring suggestion:</div>
                <p align="justify">An <i><b>Adapter</i></b> must adapt a single type of item or delegate to specialized <i><b>Adapters</i></b> --
                  remove business logic and business decisions of <i><b>Adapter</i></b>.</p>
            </div>
          </div>

        </div>

      </section>

      <hr class="m-0">

      <section class="resume-section p-3 p-lg-5 d-flex flex-column" id="resourcesmells">
        <div class="my-auto">
          <h2 class="mb-5">Resource Smells</h2>

          <div class="subheading mb-5">Here are presented 11 Resource Smells.<p></div>


            <div class="resume-item d-flex flex-column flex-md-row mb-5">
              <div class="resume-content mr-auto">
                <h3 class="mb-0">No Naming Pattern</h3>
                <p align="justify">This smell happens when resources (<i><b>layout</i></b>, <i><b>string</i></b>, <i><b>style</i></b>, <i><b>drawables</i></b>) do not
                  follow a naming pattern.
                  More specifically, it happens when the file where the resource is located and its internal name (i.e., how the resource is called inside the source code) are different.
                  These different names are a cause of confusion among developers.</p>
                  <div class="subheading mb-3">Refactoring suggestion:</div>
                  <p align="justify">Start the name of a string with the name of the screen where it will be used. It is important to have a good naming convention.</p>
              </div>
            </div>

            <div class="resume-item d-flex flex-column flex-md-row mb-5">
              <div class="resume-content mr-auto">
                <h3 class="mb-0">Missing Image</h3>
                <p align="justify">This code smell happens when the system contains only a single version of its <i><b>.png</i></b>, <i><b>.jpg</i></b>, or <i><b>.gif</i></b> images.
                  The Android platform requires images to be available in more than one size or resolution to perform optimizations.</p>
                  <div class="subheading mb-3">Refactoring suggestion:</div>
                  <p align="justify">Create folders for various resolutions and put the correct images.</p>
              </div>
            </div>

            <div class="resume-item d-flex flex-column flex-md-row mb-5">
              <div class="resume-content mr-auto">
                <h3 class="mb-0">Magic Resource</h3>
                <p align="justify">A smell that results when resources (e.g., <i><b>layout</i></b>, <i><b>string</i></b>, and <i><b>style</i></b>) are hard-coded instead of pointing to an existing resource.</p>
            <div class="subheading mb-3">Example:</div>
            <pre class="prettyprint lang-java">
&lt;?xml version="1.0" encoding="utf-8"?>
&lt;RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    xmlns:tools="http://schemas.android.com/tools"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:orientation="vertical">

    &lt;TextView
        android:id="@+id/txt_warning_message"
        android:layout_width="match_parent"
        android:layout_height="40dp"
        android:text="Ops! Seens that you don't have any item to show yet!" />

&lt;/RelativeLayout></pre>
                  <div class="subheading mb-3">Refactoring suggestion:</div>
                  <p align="justify">Remove all embedded strings and colors from <i><b>android:text</i></b> and
                    <i><b>android:.*Color.*</i></b> attribute, respectively.
                    Then, move all string to <i><b>res/values/strings.xml</i></b> and move all colors to <i><b>res/values/colors.xml</i></b>.
                    After, reference all the strings and colors into the <i><b>layout.xml</i></b>.</p>
              </div>
            </div>

            <div class="resume-item d-flex flex-column flex-md-row mb-5">
              <div class="resume-content mr-auto">
                <h3 class="mb-0">Deep Nested Layout</h3>
                <p align="justify">Deep nesting when constructing layout resources was considered a code smell.</p>
            <div class="subheading mb-3">Example:</div>
            <pre class="prettyprint lang-java">
&lt;RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:orientation="vertical">

    &lt;RelativeLayout
        android:id="@+id/main_tool_bar"
        android:layout_width="match_parent"
        android:layout_height="@dimen/activity_toolbar_height"
        android:layout_alignParentBottom="true"
        android:layout_alignParentLeft="true" >

        &lt;HorizontalScrollView
            android:layout_width="match_parent"
            android:layout_height="@dimen/activity_toolbar_height"
            android:layout_alignParentTop="true"
            android:background="?attr/colorPrimary"
            android:paddingBottom="@dimen/activity_palette_vertical_padding"
            android:paddingTop="@dimen/activity_palette_vertical_padding" >

            &lt;LinearLayout
                android:id="@+id/main_palette_view"
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:gravity="center_vertical"
                android:orientation="horizontal" >

                &lt;LinearLayout
                    style="@style/DialogTextEditBackgroundStyle"
                    android:layout_width="wrap_content"
                    android:layout_height="wrap_content">
                    &lt;com.mkulesh.micromath.widgets.CustomEditText
                        android:id="@+id/hidden_edit_text"
                        style="@style/DialogTextEditStyle"
                        android:layout_width="@dimen/activity_toolbar_height"
                        android:layout_height="@dimen/activity_hidden_text_height"
                        android:paddingTop="3dp" />
                &lt;/LinearLayout>

            &lt;/LinearLayout>
        &lt;/HorizontalScrollView>

        &lt;!-- more code here -->
    &lt;/RelativeLayout>
&lt;/RelativeLayout></pre>
                  <div class="subheading mb-3">Refactoring suggestion:</div>
                  <p align="justify">Remove hierarchies from long views, that is, deeply nested structures should not exist.</p>
              </div>
            </div>

            <div class="resume-item d-flex flex-column flex-md-row mb-5">
              <div class="resume-content mr-auto">
                <h3 class="mb-0">Unnecessary Image</h3>
                <p align="justify">Android has resources that can replace images.
                  The smell emerges when the system has images with, for example,
                  pure solid colors or gradients, which could be replaced by Android’s native <i><b>shapes</i></b>.</p>
                  <div class="subheading mb-3">Refactoring suggestion:</div>
                  <p align="justify">Using <i><b>.jpg</i></b> or <i><b>.png</i></b> for simple shapes is bad, just draw them through <i><b>Drawable Resources</i></b>.</p>
              </div>
            </div>

            <div class="resume-item d-flex flex-column flex-md-row mb-5">
              <div class="resume-content mr-auto">
                <h3 class="mb-0">Long or Repeated Layout</h3>
                <p align="justify">The code smell emerges when long or duplicated <i><b>layout</i></b> resources (instead of good reuse) occur in the source code.</p>
            <div class="subheading mb-3">Example:</div>
            <pre class="prettyprint lang-java">
&lt;?xml version="1.0" encoding="utf-8"?>
&lt;RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    xmlns:tools="http://schemas.android.com/tools"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:orientation="vertical">

    &lt;RelativeLayout
      android:layout_width="match_parent"
        android:layout_height="match_parent"
        android:orientation="vertical">
        &lt;TextView
            android:id="@+id/txt_name"
            android:layout_width="match_parent"
            android:layout_height="40dp"
            android:text="Nome completo:" />

        &lt;EditText
            android:id="@+id/edt_name"
            android:layout_width="match_parent"
            android:layout_height="40dp" />
    &lt;/RelativeLayout>

    &lt;RelativeLayout
      android:layout_width="match_parent"
        android:layout_height="match_parent"
        android:orientation="vertical">
        &lt;TextView
            android:id="@+id/txt_surname"
            android:layout_width="match_parent"
            android:layout_height="40dp"
            android:text="Nome completo:" />

        &lt;EditText
            android:id="@+id/edt_surname"
            android:layout_width="match_parent"
            android:layout_height="40dp" />
    &lt;/RelativeLayout>

    &lt;RelativeLayout
      android:layout_width="match_parent"
        android:layout_height="match_parent"
        android:orientation="vertical">
        &lt;TextView
            android:id="@+id/txt_email"
            android:layout_width="match_parent"
            android:layout_height="40dp"
            android:text="Nome completo:" />

        &lt;EditText
            android:id="@+id/edt_email"
            android:layout_width="match_parent"
            android:layout_height="40dp" />
    &lt;/RelativeLayout>

    &lt;!-- more code here -->
&lt;/RelativeLayout></pre>
                  <div class="subheading mb-3">Refactoring suggestion:</div>
                  <p align="justify">Add include statements. It is a good practice to use includes for some similar layout piece</p>
              </div>
            </div>

            <div class="resume-item d-flex flex-column flex-md-row mb-5">
              <div class="resume-content mr-auto">
                <h3 class="mb-0">God Style Resource</h3>
                <p align="justify">Long <i><b>style</i></b> resources. Symptoms of this smell happen when all styles are defined in the same <i><b>styles.xml</i></b>.</p>
                  <div class="subheading mb-3">Refactoring suggestion:</div>
                  <p align="justify">If possible, separate more than the standard <i><b>styles.xml</i></b> file,
                    since you can declare multiple style XML files for the same configuration.
                    Divide all styles. Themes and styles is a rational choice.</p>
              </div>
            </div>

            <div class="resume-item d-flex flex-column flex-md-row mb-5">
              <div class="resume-content mr-auto">
                <h3 class="mb-0">God String Resource</h3>
                <p align="justify">Long <i><b>string</i></b> resources.
                  Developers should separate their string resources according to some rule, e.g., one string resource per screen.</p>
                  <div class="subheading mb-3">Refactoring suggestion:</div>
                  <p align="justify">All <i><b>Activity</i></b> should have a specific <i><b>.XML</i></b> file to manage its strings.
                    Therefore, for each <i><b>Activity</i></b> in an App create a file into <i><b>res/values/string*.xml</i></b>.</p>
              </div>
            </div>

            <div class="resume-item d-flex flex-column flex-md-row mb-5">
              <div class="resume-content mr-auto">
                <h3 class="mb-0">Inappropriate String Reuse</h3>
                <p align="justify">Developers reuse strings among the different UIs of the application.
                  For example, the string “Name” might appear in many parts of the app; thus, developers write this string only once in a string resource file, and reuse it whenever they need it.
                  However, the smell happens when developers reuse the same <i><b>string</i></b> in different parts of the system just because the string is coincidentally the same, and not because they represent the same thing in the UI.
                  For example, in one part of the app, “name” might refer to the name of the user, whereas in another part of the app, “name” might refer to the name of the user’s favourite band.
                  Reusing strings just because of their similarity might lead to two problems:
                  First, if the developer decides to change the string, s/he needs to be aware that the changes will be reflected throughout the entire application (and might not be what s/he wants).
                  Second, when adding support for multiple languages, a language might need two different words to express what another language might need just one (thus, making internationalization harder).</p>
                  <div class="subheading mb-3">Refactoring suggestion:</div>
                  <p align="justify">All screen should have its own string resource.
                    Therefore, for each screen in a App create a file into <i><b>res/values/name.xml</i></b>.</p>
              </div>
            </div>

            <div class="resume-item d-flex flex-column flex-md-row mb-5">
              <div class="resume-content mr-auto">
                <h3 class="mb-0">Duplicate Style Attributes</h3>
                <p align="justify">Android developers often choose to define the style of an UI element directly into the layout file.
                  However, this might lead to unnecessary duplication (e.g., the same complex style appears in different components).
                  The existence of duplicated style definitions in different components is an indication of this code smell.</p>
            <div class="subheading mb-3">Example:</div>
            <pre class="prettyprint lang-java">
&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:tools="http://schemas.android.com/tools"
    android:layout_width="match_parent"
    android:layout_height="wrap_content"
    android:padding="@dimen/widget_margin"
    android:orientation="horizontal"
    android:weightSum="3"
    android:background="@drawable/rounded_corner"
    android:previewImage="@drawable/weather_widget_preview"
    android:minHeight="40dp"
    android:minWidth="250dp">

    &lt;ImageView
        android:id="@+id/widget_city_weather_image_view"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:adjustViewBounds="true"
        android:scaleType="centerCrop"
        android:src="@mipmap/weather_icon_sunny_with_clouds"
        android:layout_weight="2"/>

    &lt;GridLayout
        android:layout_width="match_parent"
        android:layout_height="match_parent"
        android:layout_gravity="center"
        android:orientation="vertical"
        android:columnCount="4"
        android:layout_weight="1"
        android:paddingStart="11dp">

        &lt;TextView
            android:id="@+id/widget_city_name"
            android:layout_width="wrap_content"
            android:text="CityName"
            android:layout_height="wrap_content"
            android:layout_weight="1"
            android:layout_marginEnd="11dp"
            android:textSize="18dp"
            android:layout_column="0"
            android:layout_row="0"
            android:layout_columnSpan="4"
            android:textStyle="bold"
            android:textColor="@color/black"/>

        &lt;TextView
            android:layout_width="wrap_content"
            android:text="Temp:"
            android:layout_height="wrap_content"
            android:layout_weight="1"
            android:layout_marginEnd="11dp"
            android:textSize="12dp"
            android:layout_column="0"
            android:layout_row="1"
            android:textColor="@color/black"/>

        &lt;TextView
            android:id="@+id/widget_city_weather_temperature"
            android:layout_width="wrap_content"
            android:text="-273,15°C"
            android:layout_height="wrap_content"
            android:layout_weight="1"
            android:layout_marginEnd="11dp"
            android:textSize="12dp"
            android:layout_column="1"
            android:layout_row="1"
            android:layout_gravity="end"
            android:textColor="@color/black"/>

        &lt;TextView
            android:layout_width="wrap_content"
            android:text="Hum:"
            android:layout_height="wrap_content"
            android:layout_weight="1"
            android:layout_marginEnd="11dp"
            android:textSize="12dp"
            android:layout_column="0"
            android:layout_row="2"
            android:textColor="@color/black"/>

        &lt;TextView
            android:id="@+id/widget_city_weather_humidity"
            android:layout_width="wrap_content"
            android:text="42%"
            android:layout_height="wrap_content"
            android:layout_weight="1"
            android:layout_marginEnd="11dp"
            android:textSize="12dp"
            android:layout_column="1"
            android:layout_row="2"
            android:layout_gravity="end"
            android:textColor="@color/black"/>

        &lt;TextView
            android:layout_width="wrap_content"
            android:text="Rise:"
            android:layout_height="wrap_content"
            android:layout_weight="1"
            android:layout_marginEnd="11dp"
            android:textSize="12dp"
            android:layout_column="2"
            android:layout_row="1"
            android:textColor="@color/black"/>

        &lt;TextView
            android:id="@+id/widget_city_weather_rise"
            android:layout_width="wrap_content"
            android:text="06:00"
            android:layout_height="wrap_content"
            android:layout_weight="1"
            android:layout_marginEnd="11dp"
            android:textSize="12dp"
            android:layout_column="3"
            android:layout_row="1"
            android:textColor="@color/black"/>
        &lt;TextView
            android:layout_width="wrap_content"
            android:text="Set:"
            android:layout_height="wrap_content"
            android:layout_weight="1"
            android:layout_marginEnd="11dp"
            android:textSize="12dp"
            android:layout_column="2"
            android:layout_row="2"
            android:layout_gravity="end"
            android:textColor="@color/black"/>

        &lt;TextView
            android:id="@+id/widget_city_weather_set"
            android:layout_width="wrap_content"
            android:text="18:00"
            android:layout_height="wrap_content"
            android:layout_weight="1"
            android:layout_marginEnd="11dp"
            android:textSize="12dp"
            android:layout_column="3"
            android:layout_row="2"
            android:textColor="@color/black"/>

        &lt;TextView
            android:layout_width="wrap_content"
            android:text="Wind:"
            android:layout_height="wrap_content"
            android:layout_weight="1"
            android:layout_marginEnd="11dp"
            android:textSize="12dp"
            android:layout_column="0"
            android:layout_row="3"
            android:textColor="@color/black"/>

        &lt;TextView
            android:id="@+id/widget_city_weather_wind"
            android:layout_width="wrap_content"
            android:text="42 km/h"
            android:layout_height="wrap_content"
            android:layout_weight="1"
            android:layout_marginEnd="11dp"
            android:textSize="12dp"
            android:layout_column="1"
            android:layout_row="3"
            android:layout_gravity="end"
            android:textColor="@color/black"/>

    &lt;/GridLayout>
&lt;/LinearLayout></pre>
                  <div class="subheading mb-3">Refactoring suggestion:</div>
                  <p align="justify">Remove all duplicate style attributes.</p>
              </div>
            </div>

            <div class="resume-item d-flex flex-column flex-md-row mb-5">
              <div class="resume-content mr-auto">
                <h3 class="mb-0">Hidden Listener</h3>
                <p align="justify">Layout resources should only be responsible for presenting data.
                  The smell appears when these resources also configure the listener that will respond to its events, such as <i><b>onClick</i></b>.
                  Such decisions make it harder for developers to identify which listeners are used.</p>
            <div class="subheading mb-3">Example:</div>
            <pre class="prettyprint lang-java">
&lt;?xml version="1.0" encoding="utf-8"?>
&lt;RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    xmlns:tools="http://schemas.android.com/tools"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:orientation="vertical">

    &lt;TextView
        android:id="@+id/txt_email"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:text="Email:" />

    &lt;EditText
        android:id="@+id/edt_email"
        android:layout_width="match_parent"
        android:layout_height="wrap_content" />

    &lt;Button
        android:id="@+id/button_confirm"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:background="@drawable/button_positive_drawable"
        android:text="@string/ok"
        android:onClick="subscribe" />

&lt;/RelativeLayout></pre>
                  <div class="subheading mb-3">Refactoring suggestion:</div>
                  <p align="justify">Remove the <i><b>View</i></b> (<i><b>Button</i></b>, <i><b>TextView</i></b>,
                    <i><b>CheckBox</i></b>, etc) element that contains the <i><b>android:onClick</i></b> attribute in the XML and add <i><b>setOnClickListener</i></b> in the corresponding <i><b>Activity</i></b> or
                    <i><b>Fragment</i></b>.</p>
              </div>
            </div>

        </div>
      </section>

    </div>

    <!-- Bootstrap core JavaScript -->
    <script src="vendor/jquery/jquery.min.js"></script>
    <script src="vendor/bootstrap/js/bootstrap.bundle.min.js"></script>

    <!-- Plugin JavaScript -->
    <script src="vendor/jquery-easing/jquery.easing.min.js"></script>

    <!-- Custom scripts for this template -->
    <script src="js/resume.min.js"></script>

  </body>

</html>
